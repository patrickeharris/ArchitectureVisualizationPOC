<head>
    <style> body { margin: 0; } </style>

    <script src="//unpkg.com/3d-force-graph"></script>
    <!--<script src="../../dist/3d-force-graph.js"></script>-->
    <link rel="stylesheet" href="styles.css">
</head>

<body>
<div class="center">
    <div class="search-box">
        <input type="text" placeholder="what are you looking for?">
        <i class="fas fa-search"></i>
        <div class="autocom_box">
            <li>Happy</li>
        </div>
    </div>
<div id="graph"></div>
</div>

<script>
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    let hoverNode = null;
    const searchWrapper = document.querySelector(".search-box")
    const inputBox = searchWrapper.querySelector("input")
    const suggBox = searchWrapper.querySelector(".autocom_box")

    const Graph = ForceGraph3D()
    (document.getElementById('graph'))
        .jsonUrl('./data.json')
        .nodeLabel('id')
        .nodeColor(node => highlightNodes.has(node) ? node === hoverNode ? 'rgb(255,0,0,1)' : 'rgba(255,160,0,0.8)' : 'rgba(0,255,255,0.6)')
        .linkWidth(link => highlightLinks.has(link) ? 4 : 1)
        .nodeAutoColorBy('group')
        .linkDirectionalParticles(link => highlightLinks.has(link) ? 4 : 0)
        .linkDirectionalParticleWidth(4)
        .onNodeDragEnd(node => {
            node.fx = node.x;
            node.fy = node.y;
            node.fz = node.z;

        })
        .onNodeClick(node => {
            // Aim at node from outside it
            const distance = 40;
            const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);

            const newPos = node.x || node.y || node.z
                ? { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }
                : { x: 0, y: 0, z: distance }; // special case if node is in (0,0,0)

            Graph.cameraPosition(
                newPos, // new position
                node, // lookAt ({ x, y, z })
                3000  // ms transition duration
            );
        })
        .onNodeHover(node => {
            // no state change
            if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

            highlightNodes.clear();
            highlightLinks.clear();
            if (node) {
                highlightNodes.add(node);
                getNeighbors(node);
            }

            hoverNode = node || null;

            updateHighlight();
        })
        .onLinkHover(link => {
            highlightNodes.clear();
            highlightLinks.clear();

            if (link) {
                highlightLinks.add(link);
                highlightNodes.add(link.source);
                highlightNodes.add(link.target);
            }

            updateHighlight();
        });

    inputBox.onkeyup = (e)=>{
        const{ nodes, links } = Graph.graphData();
        highlightNodes.clear();
        highlightLinks.clear();
        let userData = e.target.value;
        let emptyArray = [];
        let searchNodes = [];
        let newLinks = [];
        if(userData){
            emptyArray = nodes.filter((data)=>{
                return data.id.toLocaleLowerCase().startsWith(userData.toLocaleLowerCase());
            });
            searchNodes = emptyArray.map((data)=>{
                return data = '<li>' + data.id + '</li>';
            });
            newLinks = links.filter((link)=>{
                return (emptyArray.includes(link.source) && emptyArray.includes(link.target)) || emptyArray.length === 0
            })
            console.log(links.length)
            console.log(newLinks.length)
            Graph.graphData({
                nodes: emptyArray,
                links: newLinks
            })
            searchWrapper.classList.add("active");
            showSuggestions(searchNodes);
            let allList = suggBox.querySelectorAll("li");
            for(let index = 0; index < allList.length; index++){
                //onclick attributes
                allList[index].setAttribute("onclick", "select(this)")
            }
        }
        else{
            searchWrapper.classList.remove("active");
            Graph.jsonUrl('./data.json')
        }
    }

    function select(element){
        const{ nodes, links } = Graph.graphData();
        let selectUserData = element.textContent;
        inputBox.value = selectUserData;
        searchWrapper.classList.remove("active");
        let emptyArray = nodes.filter((data)=>{
            return data.id.startsWith(selectUserData);
        });
    }

    function showSuggestions(list){
        let listData;
        if(!list.length){
            let userValue = inputBox.value;
            listData = '<li>' + userValue + '</li>';
        }
        else{
            listData = list.join('');
        }
        suggBox.innerHTML = listData;
    }
    window.select = select;

    function updateHighlight() {
        // trigger update of highlighted objects in scene
        Graph
            .nodeColor(Graph.nodeColor())
            .linkWidth(Graph.linkWidth())
            .linkDirectionalParticles(Graph.linkDirectionalParticles());
    }

    function getNeighbors(node){
        const{ nodes, links } = Graph.graphData();
        console.log(node.id);
        links.forEach((link) => {if(link.source === node || link.target === node){
            highlightLinks.add(link);
            if(!highlightNodes.has(link.source)){
                highlightNodes.add(link.source);
            }
            if(!highlightNodes.has(link.target)){
                highlightNodes.add(link.target);
            }
        }})
        updateHighlight();
    }

</script>
</body>