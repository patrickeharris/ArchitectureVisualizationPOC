<head>
    <style> body { margin: 0; } </style>

    <script src="//unpkg.com/3d-force-graph@1.70.10"></script>
    <!--<script src="../../dist/3d-force-graph.js"></script>-->
    <link rel="stylesheet" href="styles.css">
</head>

<body>
<div class="center">
    <div class="search-box">
        <input type="text" placeholder="what are you looking for?">
        <i class="fas fa-search"></i>
        <div class="autocom_box">
            <li>Happy</li>
        </div>
    </div>
<div id="graph"></div>
</div>
<div class="wrapper">
    <div class="content">
        <ul class="menu">
            <li class="item" onclick="getNeighborsSelected()">
                <i class="uil uil-eye"></i>
                <span>Show Neighbors</span>
            </li>
            <li class="item share">
                <div>
                    <i class="uil uil-share"></i>
                    <span>Share</span>
                </div>
                <i class="uil uil-angle-right"></i>
                <ul class="share-menu">
                    <li class="item">
                        <i class="uil uil-twitter-alt"></i>
                        <span>Twitter</span>
                    </li>
                    <li class="item">
                        <i class="uil uil-instagram"></i>
                        <span>Instagram</span>
                    </li>
                    <li class="item">
                        <i class="uil uil-dribbble"></i>
                        <span>Dribble</span>
                    </li>
                    <li class="item">
                        <i class="uil uil-telegram-alt"></i>
                        <span>Telegram</span>
                    </li>
                </ul>
            </li>
            <li class="item" onclick="recolor()">
                <i class="uil uil-link-alt"></i>
                <span>Get Link</span>
            </li>
            <li class="item">
                <i class="uil uil-edit"></i>
                <span>Rename</span>
            </li>
            <li class="item">
                <i class="uil uil-trash-alt"></i>
                <span>Delete</span>
            </li>
        </ul>
        <div class="setting">
            <li class="item">
                <i class="uil uil-setting"></i>
                <span>Settings</span>
            </li>
        </div>
    </div>
</div>

<div>
    <input id="menuToggle" type="checkbox">
    <div class="infobox md-card">
        <div class="md-card-content">
            <h2 id="nodeName">Name</h2>
            <span class="md-caption">Something cool.</span>
            <p>Other stuff.</p>
        </div>
        <div class="md-card-btns">
            <label for="menuToggle" class="md-button">Close Box</label>
        </div>
    </div>
</div>

<script type="module">
    import { UnrealBloomPass } from '//cdn.skypack.dev/three@0.136/examples/jsm/postprocessing/UnrealBloomPass.js';
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    let hoverNode = null;
    const searchWrapper = document.querySelector(".search-box")
    const inputBox = searchWrapper.querySelector("input")
    const suggBox = searchWrapper.querySelector(".autocom_box")
    const contextMenu = document.querySelector(".wrapper");
    const shareMenu = contextMenu.querySelector(".share-menu");
    let selectedNode = null;
    let allNodes = [];

    document.addEventListener("click", () => {
        contextMenu.style.visibility = "hidden";
        //selectedNode = null;
        //console.log(selectedNode +"yeye")
    });

    const Graph = ForceGraph3D()
    (document.getElementById('graph'))
        .jsonUrl('./data.json')
        .nodeLabel('id')
        .nodeColor(node => highlightNodes.has(node) ? node === hoverNode ? 'rgb(255,0,0,1)' : 'rgba(255,160,0,0.8)' : 'rgba(0,255,255,0.6)')
        .linkWidth(link => highlightLinks.has(link) ? 4 : 1)
        .nodeAutoColorBy('group')
        .linkDirectionalParticles(link => highlightLinks.has(link) ? 4 : 0)
        .linkDirectionalParticleWidth(4)
        .nodeVisibility((node) => customNodeVisibility(node))
        .linkVisibility((link) => customLinkVisibility(link))
        .onNodeDragEnd(node => {
            node.fx = node.x;
            node.fy = node.y;
            node.fz = node.z;

        })
        .onNodeClick(node => {
            // Aim at node from outside it
            const distance = 40;
            const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);

            const newPos = node.x || node.y || node.z
                ? { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }
                : { x: 0, y: 0, z: distance }; // special case if node is in (0,0,0)

            Graph.cameraPosition(
                newPos, // new position
                node, // lookAt ({ x, y, z })
                3000  // ms transition duration
            );
            let emptyArray = [];
            emptyArray.push(node);
            Graph.graphData({
                nodes: emptyArray,
                links: []
            })
            const cb = document.querySelector('#menuToggle');
            cb.checked = true;
            document.getElementById("nodeName").innerHTML = node.id
        })
        .onNodeRightClick((node, e) =>{
            selectedNode = node;
            console.log("ISID?: " + node.id)
            e.preventDefault();
            let x = e.offsetX, y = e.offsetY,
                winWidth = window.innerWidth,
                winHeight = window.innerHeight,
                cmWidth = contextMenu.offsetWidth,
                cmHeight = contextMenu.offsetHeight;

            if(x > (winWidth - cmWidth - shareMenu.offsetWidth)) {
                shareMenu.style.left = "-200px";
            } else {
                shareMenu.style.left = "";
                shareMenu.style.right = "-200px";
            }

            x = x > winWidth - cmWidth ? winWidth - cmWidth - 5 : x;
            y = y > winHeight - cmHeight ? winHeight - cmHeight - 5 : y;

            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.style.visibility = "visible";
            console.log(node+"no")
        })
        .onNodeHover(node => {
            // no state change
            if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

            highlightNodes.clear();
            highlightLinks.clear();
            if (node) {
                highlightNodes.add(node);
                getNeighbors(node);
            }

            hoverNode = node || null;

            updateHighlight();
        })
        .onLinkHover(link => {
            highlightNodes.clear();
            highlightLinks.clear();

            if (link) {
                highlightLinks.add(link);
                highlightNodes.add(link.source);
                highlightNodes.add(link.target);
            }

            updateHighlight();
        });

    inputBox.onkeyup = (e)=>{
        let { nodes, links } = Graph.graphData();
        highlightNodes.clear();
        highlightLinks.clear();
        const cb = document.querySelector('#menuToggle');
        cb.checked = false;
        let userData = e.target.value;
        let emptyArray = [];
        allNodes = []
        if(userData){
            emptyArray = nodes.filter((data)=>{
                if(!data.id.toLocaleLowerCase().startsWith(userData.toLocaleLowerCase())){
                    allNodes.push(data)
                }
                return data.id.toLocaleLowerCase().startsWith(userData.toLocaleLowerCase());
            });
            emptyArray = emptyArray.map((data)=>{
                return data = '<li>' + data.id + '</li>';
            });
            reset()
            searchWrapper.classList.add("active");
            showSuggestions(emptyArray);
            let allList = suggBox.querySelectorAll("li");
            for(let index = 0; index < allList.length; index++){
                allList[index].setAttribute("onclick", "select(this)")
            }
        }
        else{
            searchWrapper.classList.remove("active");
            allNodes = []
            reset()
        }
    }

    function select(element){
        let selectUserData = element.textContent;
        inputBox.value = selectUserData;
        searchWrapper.classList.remove("active");
        let j = 0;

        for(let i = 0; i < nodes.length; i++){
            if(nodes[i].id.startsWith(selectUserData)){
                j = i
            }
            else{
                allNodes.push(nodes[i])
            }
        }
        reset()
        const cb = document.querySelector('#menuToggle');
        cb.checked = true;
        document.getElementById("nodeName").innerHTML = nodes[j].id
    }

    function recolor(){
        console.log("skh")
        Graph.nodeColor('color').nodeAutoColorBy('group')
        const bloomPass = new UnrealBloomPass();
        bloomPass.strength = 3;
        bloomPass.radius = 1;
        bloomPass.threshold = 0.1;
        Graph.postProcessingComposer().addPass(bloomPass);
    }

    function showSuggestions(list){
        let listData;
        if(!list.length){
            let userValue = inputBox.value;
            listData = '<li>' + userValue + '</li>';
        }
        else{
            listData = list.join('');
        }
        suggBox.innerHTML = listData;
    }
    window.select = select;

    function updateHighlight() {
        // trigger update of highlighted objects in scene
        Graph
            .nodeColor(Graph.nodeColor())
            .linkWidth(Graph.linkWidth())
            .linkDirectionalParticles(Graph.linkDirectionalParticles());
    }

    function getNeighbors(node){
        let { nodes, links } = Graph.graphData();
        console.log(node.id);
        links.forEach((link) => {if(link.source === node || link.target === node){
            highlightLinks.add(link);
            if(!highlightNodes.has(link.source)){
                highlightNodes.add(link.source);
            }
            if(!highlightNodes.has(link.target)){
                highlightNodes.add(link.target);
            }
        }})
        updateHighlight();
    }

    function reset(){
        Graph.
        nodeVisibility((node) => customNodeVisibility(node)).
        linkVisibility((link) => customLinkVisibility(link));
        Graph.refresh();
    }

    function getNeighborsSelected(){
        console.log("ID" + selectedNode.id);
        let { nodes, links } = Graph.graphData();
        let result = [];
        allNodes = nodes
        let newLinks = links.filter((link) => {
            if(link.source.id === selectedNode.id || link.target.id === selectedNode.id){
                if(allNodes.includes(link.source)){
                    allNodes.push(link.source)
                }

                if(allNodes.includes(link.target)){
                    allNodes.push(link.target)
                }
            }
            return link.source.id === selectedNode.id || link.target.id === selectedNode.id
        });
        let searchNodes = nodes.filter((node) => {
            return node.id === selectedNode.id
        });
        reset()
        console.log(searchNodes.length)
        console.log(newLinks.length)
        /*links.forEach((link) => {if(link.source === selectedNode || link.target === selectedNode){
            newLinks.push(link);
            if(!highlightNodes.has(link.source)){
                highlightNodes.add(link.source);
                searchNodes.push(link.source)
                console.log("ADDING")
            }
            if(!highlightNodes.has(link.target)){
                highlightNodes.add(link.target);
                searchNodes.push(link.target)
                console.log("ADDING")
            }
        }})*/
    }

    function customNodeVisibility(node) {
        if(allNodes.includes(node))
            return false
        return true
    }

    function customLinkVisibility(link) {
        return customNodeVisibility(link.source) && customNodeVisibility(link.target);
    }

    window.recolor = recolor;
    window.getNeighborsSelected = getNeighborsSelected;

</script>
</body>